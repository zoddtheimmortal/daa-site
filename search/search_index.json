{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Clique Listing Algorithms","text":""},{"location":"#cliques","title":"Cliques","text":"<p>In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. That is, a clique of a graph G is an induced subgraph of G that is complete.</p> <p>In computer science, the clique problem is the computational problem of finding a maximum clique, or all cliques, in a given graph. It is NP-complete, one of Karp's 21 NP-complete problems.</p>"},{"location":"#algorithms","title":"Algorithms","text":"<ul> <li>Arboricity and Subgraph Listing Algorithms - 1985</li> <li>Computational Techniques for Maximum Clique Problems - 2006</li> <li>Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time - 2010</li> </ul>"},{"location":"#clique-visualization","title":"Clique Visualization","text":"<p>Use your mouse to move the nodes of the graph!</p> <p>For Architecture and Dataset info.</p>"},{"location":"arboricity/","title":"Arboricity and Subgraph Listing Algorithms","text":"<p>Norishige Chiba and Takao Nishizeki</p> <p>The following C++ implementations are based on Chiba &amp; Nishizeki (1985).</p>"},{"location":"arboricity/#pseudo-code","title":"Pseudo Code","text":"<pre><code>procedure UPDATE (i, C);\nbegin\n  if i = n + 1 then\n    print out a new clique C\n  else\n    begin\n      if C - N(i) \u2260 \u2205 then UPDATE (i + 1, C);\n\n      { Prepare for tests }\n      { Compute T[y] = |N(y) \u2229 C \u2229 N(i)| for y \u2208 V - C - {i} }\n      for each vertex x \u2208 C \u2229 N(i)\n        do for each vertex y \u2208 N(x) - C - {i}\n          do T[y] := T[y] + 1;\n\n      { Compute S[y] = |N(y) \u2229 (C - N(i))| for y \u2208 V - C }\n      for each vertex x \u2208 C - N(i)\n        do for each vertex y \u2208 N(x) - C\n          do S[y] := S[y] + 1;\n\n      FLAG := true;\n\n      { Maximality test }\n      if there exists a vertex y \u2208 N(i) - C such that y &lt; i and T[y] = |C \u2229 N(i)|\n        then FLAG := false; { (C \u2229 N(i)) \u222a {i} is not a clique of G }\n\n      { Lexicographic test }\n      { C \u2229 N(i) corresponds to C_i in Lemma 6 }\n      sort all the vertices in C - N(i) in ascending order j\u2081 &lt; j\u2082 &lt; ... &lt; j\u209a,\n      where p = |C - N(i)|;\n\n      for k := 1 to p\n        do for each vertex y \u2208 N(j\u2096) - C such that y &lt; i and T[y] = |C \u2229 N(i)|\n          do\n            if y = j\u2096 then\n              S[y] := S[y] - 1 { Alter S[y] to S(y) }\n                else\n           if (j\u2096 is the first vertex which satisfies y &lt; j\u2096)\n                     then { S[y] := S(j\u2096); }\n                     if (S[y] + k = p) and (y \u2265 j\u2096\u208b\u2081) and (j0 = 0)\n                        then FLAG := false; { C is not lexicographically largest }\n\n       if C \u2229 N(i) \u2260 \u2205\n        then for each vertex y \u2209 C \u222a {i} such that y &lt; i, T[y] = |C \u2229 N(i)| and S[y] = 0\n          do begin\n            { Access y from the adjacency list of a vertex in C \u2229 N(i) }\n            if j\u209a &lt; y then FLAG := false; { C is not lexicographically largest }\n          end;\n       else if j\u209a &lt; i - 1 then FLAG := false; { C is not lexicographically largest }\n\n      { Reinitialize S and T }\n      for each vertex x \u2208 C \u2229 N(i)\n        do for each vertex y \u2208 N(x) - C - {i}\n          do T[y] := 0;\n\n      for each vertex x \u2208 C - N(i)\n        do for each vertex y \u2208 N(x) - C\n          do S[y] := 0;\n\n      { FLAG is true if and only if (C \u2229 N(i)) \u222a {i} is a clique of G, and C is the\n      lexicographically largest clique of G_i containing C \u2229 N(i). }\n\n      if FLAG then\n        begin\n          SAVE := C - N(i);\n          C := (C \u2229 N(i)) \u222a {i};\n          UPDATE (i + 1, C);\n          C := (C - {i}) \u222a SAVE;\n        end;\n    end;\nend;\n\nbegin { of CLIQUE }\n  number the vertices of a given graph G in such a way that\n  d(1) \u2264 d(2) \u2264 ... \u2264 d(n);\n\n  for i := 1 to n { Initialize S and T }\n    do begin\n      S[i] := 0;\n      T[i] := 0;\n    end;\n\n  C := {1};\n  UPDATE(2, C);\nend { of CLIQUE };\n</code></pre>"},{"location":"arboricity/#usage","title":"Usage","text":"<p>Save any of the following code as <code>chiba.cpp</code>.</p> <p>Run the following code in a terminal.</p> <p><code>sudo</code> permissions are required to increase the recursion stack limit.</p> <pre><code>g++ -O3 chiba.cpp\nsudo ./a.out &lt;path_for_input_file&gt;  &lt;path_for_output_file&gt;\n</code></pre> <p>We use the <code>-O3 flag</code> as it enables aggressive optimizations that can significantly improve the performance of the program</p> <p>Output for the code will be saved in <code>path_for_output_file</code>.</p> <p>Terminal will display errors, debugging and progress statements.</p>"},{"location":"arboricity/#naive-approach","title":"Naive Approach","text":"<p>The Naive Approach is a one-to-one implementation of the research paper. No additional optimizations have been added.</p>"},{"location":"arboricity/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;sys/resource.h&gt;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\n\n#define all(x) x.begin(), x.end()\n#define fr(i, a, b) for (ll i = a; i &lt; (b); ++i)\n#define rf(i, a, b) for (ll i = b; i &gt;=(a); i--)\n#define nL \"\\n\"\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(nullptr)\n\n#define FREQ 1000\n\nll n,m;\nvector&lt;set&lt;int&gt;&gt; adj;\nvector&lt;int&gt; S,T;\n\nll max_clique_size = 0;\nll clique_count = 0;\nunordered_map&lt;ll,ll&gt; distribution;\n\nvoid UPDATE(int i, set&lt;int&gt;&amp;C){\n    if(i&gt;n) return;\n    if(i==n){\n        clique_count++;\n        distribution[C.size()]++;\n        max_clique_size=max(max_clique_size,(ll)C.size());\n\n        if(clique_count%FREQ==0){\n            cerr&lt;&lt;\"Found: \"&lt;&lt;clique_count&lt;&lt;\", Max Clique Size: \"&lt;&lt;max_clique_size&lt;&lt;nL;\n        }\n        return;\n    }\n\n    set&lt;int&gt; intersection;\n    set_intersection(C.begin(),C.end(),adj[i].begin(),adj[i].end(),\n    inserter(intersection, intersection.begin()));\n\n    set&lt;int&gt; difference;\n    set_difference(C.begin(),C.end(),adj[i].begin(),adj[i].end(),\n    inserter(difference, difference.begin()));\n\n    if(!difference.empty()){\n        UPDATE(i+1,C);\n    }\n\n    for(int x:intersection){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end() &amp;&amp; y!=i){\n                T[y]++;\n            }\n        }\n    }\n\n    for(int x:difference){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()){\n                S[y]++;\n            }\n        }\n    }\n\n    bool FLAG=true;\n\n    for(int y:adj[i]){\n        if(C.find(y)==C.end() &amp;&amp; y&lt;i &amp;&amp; T[y]==intersection.size()){\n            FLAG=false;\n        }\n    }\n\n    vector&lt;int&gt; diff_idx(difference.begin(), difference.end());\n    sort(diff_idx.begin(), diff_idx.end());\n\n    int p=diff_idx.size();\n    fr(k,1,p+1){\n        int jk=diff_idx[k-1];\n        bool first_handled=false;\n\n        for(int y:adj[jk]){\n\n            if(C.find(y)==C.end()&amp;&amp;y&lt;i&amp;&amp;T[y]==intersection.size()){\n                if(y&gt;=jk){\n                    S[y]--;\n                }\n                else{\n                    if(!first_handled){\n                        if(S[y]+k-1==p&amp;&amp;((k-1==0&amp;&amp;y&gt;=0)||(y&gt;=diff_idx[k-2]))){\n                            FLAG=false;\n                            first_handled=true;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n\n    int jp=(!diff_idx.empty())?diff_idx.back():0;\n    if(!intersection.empty()){\n        fr(y,0,i){\n            if(C.find(y)==C.end()&amp;&amp;y!=i&amp;&amp;\n            T[y]==intersection.size()&amp;&amp;S[y]==0){\n                if(jp&lt;y){\n                    FLAG=false;\n                    break;\n                }\n            }\n        }\n    }\n    else if(jp&lt;i-1){\n        FLAG=false;\n    }\n\n    for(int x:intersection){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()&amp;&amp;y!=i){\n                T[y]=0;\n            }\n        }\n    }\n\n    for(int x:difference){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()){\n                S[y]=0;\n            }\n        }\n    }\n\n    if(FLAG){\n        set&lt;int&gt; SAVE;\n        for(int x:difference){\n            SAVE.insert(x);\n        }\n\n        C.clear();\n        for(int x:intersection){\n            C.insert(x);\n        }\n        C.insert(i);\n\n        UPDATE(i+1,C);\n\n        C.erase(i);\n        for(int x:SAVE){\n            C.insert(x);\n        }\n    }\n}\n\nvoid CLIQUE(){\n    int start_vertex = 0;\n    while(adj[start_vertex].empty()){\n        start_vertex++;\n    }\n\n    S.assign(n,0);\n    T.assign(n,0);\n\n    set&lt;int&gt; C = {start_vertex};\n    UPDATE(start_vertex+1,C);\n}\n\nvoid solve(){\n    cin&gt;&gt;n&gt;&gt;m;\n    adj.resize(n);\n\n    cerr&lt;&lt;\"Input Size: \"&lt;&lt;n&lt;&lt;\", Edges: \"&lt;&lt;m&lt;&lt;nL;\n    cerr&lt;&lt;\"Reading Input...\"&lt;&lt;nL;\n    fr(i,0,m){\n        ll f,s;\n        cin&gt;&gt;f&gt;&gt;s;\n        adj[f].insert(s);\n        adj[s].insert(f);\n    }\n\n    vector&lt;pair&lt;int,int&gt;&gt; degree;\n    fr(i,0,n){\n        degree.push_back({adj[i].size(),i});\n    }\n    sort(all(degree));\n    unordered_map&lt;int,int&gt; new_index;\n    fr(i,0,n){\n        new_index[degree[i].second] = i;\n    }\n    vector&lt;set&lt;int&gt;&gt; new_adj(n);\n    fr(i,0,n){\n        for(int x : adj[i]){\n            new_adj[new_index[i]].insert(new_index[x]);\n        }\n    }\n    adj = new_adj;\n\n    cerr&lt;&lt;\"Input Read Complete.\"&lt;&lt;nL;\n    cerr&lt;&lt;\"Starting Clique Search...\"&lt;&lt;nL;\n    auto start_time=chrono::high_resolution_clock::now();\n    CLIQUE();\n    auto end_time=chrono::high_resolution_clock::now();\n    cerr&lt;&lt;\"Clique Search Complete.\"&lt;&lt;nL;\n\n    auto duration = chrono::duration_cast&lt;chrono::microseconds&gt;(end_time - start_time);\n    cout&lt;&lt;\"Time taken: \"&lt;&lt;duration.count()/1000&lt;&lt;\" ms\"&lt;&lt;nL;\n    cout&lt;&lt;\"Max Clique Size: \"&lt;&lt;max_clique_size&lt;&lt;nL;\n    cout&lt;&lt;\"Clique Count: \"&lt;&lt;clique_count&lt;&lt;nL;\n    cout&lt;&lt;\"Distribution: \"&lt;&lt;nL;\n    for(auto&amp; [size, count] : distribution){\n        cout&lt;&lt;\"Size \"&lt;&lt;size&lt;&lt;\": \"&lt;&lt;count&lt;&lt;nL;\n    }\n}\n\nint main(int argc, char* argv[]){\n    fast_io;\n\n    if(argc &lt; 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input_file&gt; &lt;output_file&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ifstream infile(argv[1]);\n    if(!infile) {\n        cerr &lt;&lt; \"Error: Could not open input file \" &lt;&lt; argv[1] &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if(!outfile) {\n        cerr &lt;&lt; \"Error: Could not open output file \" &lt;&lt; argv[2] &lt;&lt; endl;\n        return 1;\n    }\n\n    cin.rdbuf(infile.rdbuf());\n    cout.rdbuf(outfile.rdbuf());\n\n    ll t=1;\n\n\n    while(t--){\n        solve();\n    }\n\n    infile.close();\n    outfile.close();\n\n    return 0;\n}\n</code></pre>"},{"location":"arboricity/#results","title":"Results","text":""},{"location":"arboricity/#wiki-vote-dataset","title":"Wiki Vote Dataset","text":"<p>The algorithm takes 12.63 mins to run on the Wiki Vote dataset. Since the optimized version runs faster than this version, this approach was not run for other datasets.</p> <pre><code>Time taken: 758266 ms\nMax Clique Size: 17\nClique Count: 459002\nDistribution:\nSize 17: 23\nSize 16: 208\nSize 15: 740\nSize 2: 8655\nSize 4: 27292\nSize 5: 48416\nSize 7: 83266\nSize 6: 68872\nSize 3: 13718\nSize 8: 76732\nSize 9: 54456\nSize 10: 35470\nSize 11: 21736\nSize 12: 11640\nSize 13: 5449\nSize 14: 2329\n</code></pre>"},{"location":"arboricity/#issues","title":"Issues","text":"<ul> <li>Due to being unoptimized, the algo runs additional code that which is not needed for every recursive call. This contributes to the slow performance of the code (mainly for larger datasets).</li> <li>Since this is a recursive approach, the algorithm may run into SEGMENTATION fault during deep recursions.</li> </ul>"},{"location":"arboricity/#optimized-approach","title":"Optimized Approach","text":""},{"location":"arboricity/#code_1","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;sys/resource.h&gt;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\n\n#define all(x) x.begin(), x.end()\n#define fr(i, a, b) for (ll i = a; i &lt; (b); ++i)\n#define rf(i, a, b) for (ll i = b; i &gt;=(a); i--)\n#define nL \"\\n\"\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(nullptr)\n\n#define FREQ 1000\n\nll n,m;\nvector&lt;set&lt;int&gt;&gt; adj;\nvector&lt;int&gt; S,T;\n\nll max_clique_size = 0;\nll clique_count = 0;\nunordered_map&lt;ll,ll&gt; distribution;\n\nvoid increase_stack_size(rlim_t stack_size = 512 * 1024 * 1024) {\n    struct rlimit rl;\n\n    int result = getrlimit(RLIMIT_STACK, &amp;rl);\n    if (result != 0) {\n        cerr &lt;&lt; \"Error getting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        return;\n    }\n\n    if (rl.rlim_cur &lt; stack_size) {\n        rl.rlim_cur = stack_size;\n        if (rl.rlim_max &lt; rl.rlim_cur) {\n            rl.rlim_max = rl.rlim_cur;\n        }\n\n        result = setrlimit(RLIMIT_STACK, &amp;rl);\n        if (result != 0) {\n            cerr &lt;&lt; \"Error setting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        } else {\n            cerr &lt;&lt; \"Stack size increased to \" &lt;&lt; (stack_size / (1024 * 1024)) &lt;&lt; \" MB\" &lt;&lt; endl;\n        }\n    }\n}\n\nvoid UPDATE(int i, set&lt;int&gt;&amp;C){\n    if(i&gt;n) return;\n    if(i==n){\n        clique_count++;\n        distribution[C.size()]++;\n        max_clique_size=max(max_clique_size,(ll)C.size());\n\n        if(clique_count%FREQ==0){\n            cerr&lt;&lt;\"Found: \"&lt;&lt;clique_count&lt;&lt;\", Max Clique Size: \"&lt;&lt;max_clique_size&lt;&lt;nL;\n        }\n        return;\n    }\n\n    vector&lt;int&gt; intersection;\n    vector&lt;int&gt; difference;\n\n    vector&lt;int&gt; adj_vec(adj[i].begin(), adj[i].end());\n\n    int p1 = 0,p2 = 0;\n    while (p1 &lt; C.size() &amp;&amp; p2 &lt; adj_vec.size()) {\n        int val1 = *next(C.begin(), p1);\n        int val2 = adj_vec[p2];\n\n        if (val1 == val2) {\n            intersection.push_back(val1);\n            p1++;\n            p2++;\n        } else if (val1 &lt; val2) {\n            difference.push_back(val1);\n            p1++;\n        } else {\n            p2++;\n        }\n    }\n\n    while (p1 &lt; C.size()) {\n        difference.push_back(*next(C.begin(), p1));\n        p1++;\n    }\n\n    if(!difference.empty()){\n        UPDATE(i+1,C);\n    }\n\n    for(int x:intersection){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end() &amp;&amp; y!=i){\n                T[y]++;\n            }\n        }\n    }\n\n    for(int x:difference){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()){\n                S[y]++;\n            }\n        }\n    }\n\n    bool FLAG=true;\n\n    for(int y:adj[i]){\n        if(C.find(y)==C.end() &amp;&amp; y&lt;i &amp;&amp; T[y]==intersection.size()){\n            FLAG=false;\n            break;\n        }\n    }\n\n    if(FLAG){\n        vector&lt;int&gt; diff_idx(difference.begin(), difference.end());\n        sort(diff_idx.begin(), diff_idx.end());\n\n        int p=diff_idx.size();\n        fr(k,1,p+1){\n            int jk=diff_idx[k-1];\n            bool first_handled=false;\n\n            for(int y:adj[jk]){\n\n                if(C.find(y)==C.end()&amp;&amp;y&lt;i&amp;&amp;T[y]==intersection.size()){\n                    if(y&gt;=jk){\n                        S[y]--;\n                    }\n                    else{\n                        if(!first_handled){\n                            if(S[y]+k-1==p&amp;&amp;((k-1==0&amp;&amp;y&gt;=0)||(y&gt;=diff_idx[k-2]))){\n                                FLAG=false;\n                                first_handled=true;\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n\n        if(FLAG){\n            int jp=(!diff_idx.empty())?diff_idx.back():0;\n            if(!intersection.empty()){\n                fr(y,0,i){\n                    if(C.find(y)==C.end()&amp;&amp;y!=i&amp;&amp;\n                    T[y]==intersection.size()&amp;&amp;S[y]==0){\n                        if(jp&lt;y){\n                            FLAG=false;\n                            break;\n                        }\n                    }\n                }\n            }\n            else if(jp&lt;i-1){\n                FLAG=false;\n            }\n        }\n    }\n\n    for(int x:intersection){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()&amp;&amp;y!=i){\n                T[y]=0;\n            }\n        }\n    }\n\n    for(int x:difference){\n        for(int y:adj[x]){\n            if(C.find(y)==C.end()){\n                S[y]=0;\n            }\n        }\n    }\n\n    if(FLAG){\n        set&lt;int&gt; SAVE(difference.begin(), difference.end());\n\n        C.clear();\n        C.insert(intersection.begin(), intersection.end());\n        C.insert(i);\n\n        UPDATE(i+1,C);\n\n        C.erase(i);\n        C.insert(SAVE.begin(), SAVE.end());\n    }\n}\n\nvoid CLIQUE(){\n    int start_vertex = 0;\n    while(adj[start_vertex].empty()){\n        start_vertex++;\n    }\n\n    S.assign(n,0);\n    T.assign(n,0);\n\n    set&lt;int&gt; C = {start_vertex};\n    UPDATE(start_vertex+1,C);\n}\n\nvoid solve(){\n    cin&gt;&gt;n&gt;&gt;m;\n    adj.resize(n);\n\n    cerr&lt;&lt;\"Input Size: \"&lt;&lt;n&lt;&lt;\", Edges: \"&lt;&lt;m&lt;&lt;nL;\n    cerr&lt;&lt;\"Reading Input...\"&lt;&lt;nL;\n    fr(i,0,m){\n        ll f,s;\n        cin&gt;&gt;f&gt;&gt;s;\n        adj[f].insert(s);\n        adj[s].insert(f);\n    }\n\n    vector&lt;pair&lt;int,int&gt;&gt; degree;\n    fr(i,0,n){\n        degree.push_back({adj[i].size(),i});\n    }\n    sort(all(degree));\n    unordered_map&lt;int,int&gt; new_index;\n    fr(i,0,n){\n        new_index[degree[i].second] = i;\n    }\n    vector&lt;set&lt;int&gt;&gt; new_adj(n);\n    fr(i,0,n){\n        for(int x : adj[i]){\n            new_adj[new_index[i]].insert(new_index[x]);\n        }\n    }\n    adj = new_adj;\n\n\n    cerr&lt;&lt;\"Input Read Complete.\"&lt;&lt;nL;\n    cerr&lt;&lt;\"Starting Clique Search...\"&lt;&lt;nL;\n    auto start_time=chrono::high_resolution_clock::now();\n    CLIQUE();\n    auto end_time=chrono::high_resolution_clock::now();\n    cerr&lt;&lt;\"Clique Search Complete.\"&lt;&lt;nL;\n\n    auto duration = chrono::duration_cast&lt;chrono::microseconds&gt;(end_time - start_time);\n    cout&lt;&lt;\"Time taken: \"&lt;&lt;duration.count()/1000&lt;&lt;\" ms\"&lt;&lt;nL;\n    cout&lt;&lt;\"Max Clique Size: \"&lt;&lt;max_clique_size&lt;&lt;nL;\n    cout&lt;&lt;\"Clique Count: \"&lt;&lt;clique_count&lt;&lt;nL;\n    cout&lt;&lt;\"Distribution: \"&lt;&lt;nL;\n    for(auto&amp; [size, count] : distribution){\n        cout&lt;&lt;\"Size \"&lt;&lt;size&lt;&lt;\": \"&lt;&lt;count&lt;&lt;nL;\n    }\n}\n\nint main(int argc, char* argv[]){\n    fast_io;\n    increase_stack_size();\n\n    if(argc &lt; 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input_file&gt; &lt;output_file&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ifstream infile(argv[1]);\n    if(!infile) {\n        cerr &lt;&lt; \"Error: Could not open input file \" &lt;&lt; argv[1] &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if(!outfile) {\n        cerr &lt;&lt; \"Error: Could not open output file \" &lt;&lt; argv[2] &lt;&lt; endl;\n        return 1;\n    }\n\n    cin.rdbuf(infile.rdbuf());\n    cout.rdbuf(outfile.rdbuf());\n\n    ll t=1;\n\n\n    while(t--){\n        solve();\n    }\n\n    infile.close();\n    outfile.close();\n\n    return 0;\n}\n</code></pre>"},{"location":"arboricity/#optimizations","title":"Optimizations","text":""},{"location":"arboricity/#flag-check","title":"FLAG Check","text":"<p>Since only Step 4, 6 and 7 from Chiba &amp; Nishizeki (Page 221) can modify the <code>FLAG</code>, we add if conditions after Step 4 and 6 to determine if going into Step 6 and 7 respectively are necessary. In Step 4 and 7, we add break conditions after <code>FLAG</code> is set to false, as further iterations won't change the state of the <code>FLAG</code>. This reduces computational costs needed for the extra steps, making our algorithm run faster.</p> <pre><code>// Step 4: First FLAG check with early exit\nfor(int y:adj[i]){\n    if(C.find(y)==C.end() &amp;&amp; y&lt;i &amp;&amp; T[y]==intersection.size()){\n        FLAG=false;\n        break;  // Early exit once FLAG is false\n    }\n}\n\n// Only proceed to Step 6 if FLAG is still true\nif(FLAG){\n    // Step 6 processing\n    // ...\n\n    // Only proceed to Step 7 if FLAG is still true after Step 6\n    if(FLAG){\n        // Step 7 processing\n        // ...\n    }\n}\n</code></pre>"},{"location":"arboricity/#optimized-intersection-and-difference-calculation","title":"Optimized Intersection and Difference Calculation","text":"<p>The intersection and difference calculations are optimized using vectors instead of sets for better performance.</p> <pre><code>vector&lt;int&gt; intersection;\nvector&lt;int&gt; difference;\nvector&lt;int&gt; adj_vec(adj[i].begin(), adj[i].end());\nint p1 = 0, p2 = 0;\nwhile (p1 &lt; C.size() &amp;&amp; p2 &lt; adj_vec.size()) {\n    int val1 = *next(C.begin(), p1);\n    int val2 = adj_vec[p2];\n    if (val1 == val2) {\n        intersection.push_back(val1);\n        p1++;\n        p2++;\n    } else if (val1 &lt; val2) {\n        difference.push_back(val1);\n        p1++;\n    } else {\n        p2++;\n    }\n}\nwhile (p1 &lt; C.size()) {\n    difference.push_back(*next(C.begin(), p1));\n    p1++;\n}\n</code></pre>"},{"location":"arboricity/#increased-stack-size","title":"Increased Stack Size","text":"<p>In the Optimized Approach, the stack size is increased to handle deeper recursion.</p> <pre><code>void increase_stack_size(rlim_t stack_size = 512 * 1024 * 1024) {\n    struct rlimit rl;\n    int result = getrlimit(RLIMIT_STACK, &amp;rl);\n    if (result != 0) {\n        cerr &lt;&lt; \"Error getting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        return;\n    }\n    if (rl.rlim_cur &lt; stack_size) {\n        rl.rlim_cur = stack_size;\n        if (rl.rlim_max &lt; rl.rlim_cur) {\n            rl.rlim_max = rl.rlim_cur;\n        }\n        result = setrlimit(RLIMIT_STACK, &amp;rl);\n        if (result != 0) {\n            cerr &lt;&lt; \"Error setting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        } else {\n            cerr &lt;&lt; \"Stack size increased to \" &lt;&lt; (stack_size / (1024 * 1024)) &lt;&lt; \" MB\" &lt;&lt; endl;\n        }\n    }\n}\n</code></pre>"},{"location":"arboricity/#results_1","title":"Results","text":""},{"location":"arboricity/#wiki-vote-dataset_1","title":"Wiki Vote Dataset","text":"<p>The algorithm takes 6.98 mins to run on the Wiki Vote dataset. This shows a 44% decrease in run time.</p> <pre><code>Time taken: 419446 ms\nMax Clique Size: 17\nClique Count: 459002\nDistribution:\nSize 17: 23\nSize 16: 208\nSize 15: 740\nSize 2: 8655\nSize 4: 27292\nSize 5: 48416\nSize 7: 83266\nSize 6: 68872\nSize 3: 13718\nSize 8: 76732\nSize 9: 54456\nSize 10: 35470\nSize 11: 21736\nSize 12: 11640\nSize 13: 5449\nSize 14: 2329\n</code></pre>"},{"location":"arboricity/#email-enron-dataset","title":"Email Enron Dataset","text":"<p>The algorithm takes 9.3 mins to run on the Email Enron dataset. This shows a 44% decrease in run time.</p> <pre><code>Time taken: 558357 ms\nMax Clique Size: 20\nClique Count: 226859\nDistribution:\nSize 20: 6\nSize 19: 10\nSize 18: 41\nSize 17: 286\nSize 16: 1178\nSize 14: 7417\nSize 2: 14070\nSize 15: 3157\nSize 4: 13319\nSize 3: 7077\nSize 5: 18143\nSize 7: 25896\nSize 6: 22715\nSize 8: 24766\nSize 9: 22884\nSize 10: 21393\nSize 13: 11487\nSize 11: 17833\nSize 12: 15181\n</code></pre>"},{"location":"arboricity/#skitter-dataset","title":"Skitter Dataset","text":"<p>The algorithm runs into <code>SEGMENTATION</code> fault after a few minutes, even when the stack size is increased to 1GB.</p>"},{"location":"arboricity/#issues_1","title":"Issues","text":"<ul> <li>Since this is also a recursive approach, the algorithm may run out of stack space and give <code>SEGMENTATION</code> fault for deep recursion. Although we can avoid this by increasing stack space, it's better to use an iterative approach.</li> </ul>"},{"location":"arboricity/#iterative-approach","title":"Iterative Approach","text":"<p>We simulate the recursion by using a stack and a custom struct which holds the same parameters as our recursive function.</p>"},{"location":"arboricity/#code_2","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;sys/resource.h&gt;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector&lt;int&gt;;\nusing vl = vector&lt;ll&gt;;\n\n#define all(x) x.begin(), x.end()\n#define fr(i, a, b) for (ll i = a; i &lt; (b); ++i)\n#define rf(i, a, b) for (ll i = b; i &gt;=(a); i--)\n#define nL \"\\n\"\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(nullptr)\n\n#define FREQ 1000\n\nll n,m;\nvector&lt;set&lt;int&gt;&gt; adj;\nvector&lt;int&gt; S,T;\n\nll max_clique_size = 0;\nll clique_count = 0;\nunordered_map&lt;ll,ll&gt; distribution;\n\nvoid UPDATE(int i, set&lt;int&gt;&amp; C) {\n    struct StackFrame {\n        int i;\n        set&lt;int&gt; C;\n        vector&lt;int&gt; intersection;\n        vector&lt;int&gt; difference;\n        vector&lt;int&gt; diff_idx;\n        bool FLAG;\n        int state;\n        set&lt;int&gt; SAVE;\n    };\n\n    stack&lt;StackFrame&gt; callStack;\n    callStack.push({i, C, {}, {}, {}, true, 0, {}});\n\n    while (!callStack.empty()) {\n        auto&amp; frame = callStack.top();\n\n        if (frame.i &gt; n) {\n            callStack.pop();\n            continue;\n        }\n\n        if (frame.i == n) {\n            clique_count++;\n            distribution[frame.C.size()]++;\n            max_clique_size = max(max_clique_size, (ll)frame.C.size());\n\n            if (clique_count % FREQ == 0) {\n                cerr &lt;&lt; \"Found: \" &lt;&lt; clique_count &lt;&lt; \", Max Clique Size: \" &lt;&lt; max_clique_size &lt;&lt; nL;\n            }\n\n            callStack.pop();\n            continue;\n        }\n\n        if (frame.state == 0) {\n            vector&lt;int&gt; adj_vec(adj[frame.i].begin(), adj[frame.i].end());\n\n            int p1 = 0, p2 = 0;\n            while (p1 &lt; frame.C.size() &amp;&amp; p2 &lt; adj_vec.size()) {\n                int val1 = *next(frame.C.begin(), p1);\n                int val2 = adj_vec[p2];\n\n                if (val1 == val2) {\n                    frame.intersection.push_back(val1);\n                    p1++;\n                    p2++;\n                } else if (val1 &lt; val2) {\n                    frame.difference.push_back(val1);\n                    p1++;\n                } else {\n                    p2++;\n                }\n            }\n\n            while (p1 &lt; frame.C.size()) {\n                frame.difference.push_back(*next(frame.C.begin(), p1));\n                p1++;\n            }\n\n            if (!frame.difference.empty()) {\n\n                frame.state = 1;\n\n\n                callStack.push({frame.i + 1, frame.C, {}, {}, {}, true, 0, {}});\n                continue;\n            } else {\n                frame.state = 1;\n            }\n        }\n\n\n        if (frame.state == 1) {\n\n            for (int x : frame.intersection) {\n                for (int y : adj[x]) {\n                    if (frame.C.find(y) == frame.C.end() &amp;&amp; y != frame.i) {\n                        T[y]++;\n                    }\n                }\n            }\n\n            for (int x : frame.difference) {\n                for (int y : adj[x]) {\n                    if (frame.C.find(y) == frame.C.end()) {\n                        S[y]++;\n                    }\n                }\n            }\n\n            frame.FLAG = true;\n\n\n            for (int y : adj[frame.i]) {\n                if (frame.C.find(y) == frame.C.end() &amp;&amp; y &lt; frame.i &amp;&amp; T[y] == frame.intersection.size()) {\n                    frame.FLAG = false;\n                    break;\n                }\n            }\n\n\n            if (frame.FLAG) {\n                frame.diff_idx = vector&lt;int&gt;(frame.difference.begin(), frame.difference.end());\n                sort(frame.diff_idx.begin(), frame.diff_idx.end());\n\n                int p = frame.diff_idx.size();\n                for (int k = 1; k &lt;= p; k++) {\n                    int jk = frame.diff_idx[k-1];\n                    bool first_handled = false;\n\n                    for (int y : adj[jk]) {\n                        if (frame.C.find(y) == frame.C.end() &amp;&amp; y &lt; frame.i &amp;&amp; T[y] == frame.intersection.size()) {\n                            if (y &gt;= jk) {\n                                S[y]--;\n                            } else {\n                                if (!first_handled) {\n                                    if (S[y] + k - 1 == p &amp;&amp; ((k - 1 == 0 &amp;&amp; y &gt;= 0) || (y &gt;= frame.diff_idx[k-2]))) {\n                                        frame.FLAG = false;\n                                        first_handled = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n\n                if (frame.FLAG) {\n                    int jp = (!frame.diff_idx.empty()) ? frame.diff_idx.back() : 0;\n                    if (!frame.intersection.empty()) {\n                        for (int y = 0; y &lt; frame.i; y++) {\n                            if (frame.C.find(y) == frame.C.end() &amp;&amp; y != frame.i &amp;&amp;\n                            T[y] == frame.intersection.size() &amp;&amp; S[y] == 0) {\n                                if (jp &lt; y) {\n                                    frame.FLAG = false;\n                                    break;\n                                }\n                            }\n                        }\n                    } else if (jp &lt; frame.i - 1) {\n                        frame.FLAG = false;\n                    }\n                }\n            }\n\n\n            for (int x : frame.intersection) {\n                for (int y : adj[x]) {\n                    if (frame.C.find(y) == frame.C.end() &amp;&amp; y != frame.i) {\n                        T[y] = 0;\n                    }\n                }\n            }\n\n            for (int x : frame.difference) {\n                for (int y : adj[x]) {\n                    if (frame.C.find(y) == frame.C.end()) {\n                        S[y] = 0;\n                    }\n                }\n            }\n\n\n            if (frame.FLAG) {\n                frame.SAVE = set&lt;int&gt;(frame.difference.begin(), frame.difference.end());\n\n                set&lt;int&gt; newC;\n                newC.insert(frame.intersection.begin(), frame.intersection.end());\n                newC.insert(frame.i);\n\n                frame.state = 2;\n\n\n                callStack.push({frame.i + 1, newC, {}, {}, {}, true, 0, {}});\n                continue;\n            } else {\n\n                callStack.pop();\n                continue;\n            }\n        }\n\n\n        if (frame.state == 2) {\n\n            if (!callStack.empty()) {\n                auto&amp; prevFrame = callStack.top();\n                prevFrame.C.erase(prevFrame.i);\n                prevFrame.C.insert(prevFrame.SAVE.begin(), prevFrame.SAVE.end());\n            }\n\n            callStack.pop();\n        }\n    }\n\n\n    if (!callStack.empty()) {\n        C = callStack.top().C;\n    }\n}\n\nvoid CLIQUE(){\n    int start_vertex = 0;\n    while(adj[start_vertex].empty()){\n        start_vertex++;\n    }\n\n    S.assign(n,0);\n    T.assign(n,0);\n\n    set&lt;int&gt; C = {start_vertex};\n    UPDATE(start_vertex+1,C);\n}\n\nvoid solve(){\n    cin&gt;&gt;n&gt;&gt;m;\n    adj.resize(n);\n\n    cerr&lt;&lt;\"Input Size: \"&lt;&lt;n&lt;&lt;\", Edges: \"&lt;&lt;m&lt;&lt;nL;\n    cerr&lt;&lt;\"Reading Input...\"&lt;&lt;nL;\n    fr(i,0,m){\n        ll f,s;\n        cin&gt;&gt;f&gt;&gt;s;\n        adj[f].insert(s);\n        adj[s].insert(f);\n    }\n\n    vector&lt;pair&lt;int,int&gt;&gt; degree;\n    fr(i,0,n){\n        degree.push_back({adj[i].size(),i});\n    }\n    sort(all(degree));\n    unordered_map&lt;int,int&gt; new_index;\n    fr(i,0,n){\n        new_index[degree[i].second] = i;\n    }\n    vector&lt;set&lt;int&gt;&gt; new_adj(n);\n    fr(i,0,n){\n        for(int x : adj[i]){\n            new_adj[new_index[i]].insert(new_index[x]);\n        }\n    }\n    adj = new_adj;\n\n\n    cerr&lt;&lt;\"Input Read Complete.\"&lt;&lt;nL;\n    cerr&lt;&lt;\"Starting Clique Search...\"&lt;&lt;nL;\n    auto start_time=chrono::high_resolution_clock::now();\n    CLIQUE();\n    auto end_time=chrono::high_resolution_clock::now();\n    cerr&lt;&lt;\"Clique Search Complete.\"&lt;&lt;nL;\n\n    auto duration = chrono::duration_cast&lt;chrono::microseconds&gt;(end_time - start_time);\n    cout&lt;&lt;\"Time taken: \"&lt;&lt;duration.count()/1000&lt;&lt;\" ms\"&lt;&lt;nL;\n    cout&lt;&lt;\"Max Clique Size: \"&lt;&lt;max_clique_size&lt;&lt;nL;\n    cout&lt;&lt;\"Clique Count: \"&lt;&lt;clique_count&lt;&lt;nL;\n    cout&lt;&lt;\"Distribution: \"&lt;&lt;nL;\n    for(auto&amp; [size, count] : distribution){\n        cout&lt;&lt;\"Size \"&lt;&lt;size&lt;&lt;\": \"&lt;&lt;count&lt;&lt;nL;\n    }\n}\n\nint main(int argc, char* argv[]){\n    fast_io;\n\n    if(argc &lt; 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input_file&gt; &lt;output_file&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ifstream infile(argv[1]);\n    if(!infile) {\n        cerr &lt;&lt; \"Error: Could not open input file \" &lt;&lt; argv[1] &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if(!outfile) {\n        cerr &lt;&lt; \"Error: Could not open output file \" &lt;&lt; argv[2] &lt;&lt; endl;\n        return 1;\n    }\n\n    cin.rdbuf(infile.rdbuf());\n    cout.rdbuf(outfile.rdbuf());\n\n    ll t=1;\n\n\n    while(t--){\n        solve();\n    }\n\n    infile.close();\n    outfile.close();\n\n    return 0;\n}\n</code></pre> <p>Here, the state variable in StackFrame holds info regarding the sequence of the call. If the call is a first call, we process it similar to a normal recursive call. But if it's not, we only run the part where the recursive function would run after it comes back from a recursive call.</p>"},{"location":"arboricity/#results_2","title":"Results","text":"<p>Results are similar to the Optimized Approach for Wiki and Email Dataset.</p> <p>For Skitter, the algorithm ran for 6hrs and found 52k cliques.</p> <p>This gives us an <code>estimated run time</code> of 4269hrs for 37M cliques. Thus, the algorithm was terminated.</p>"},{"location":"archds/","title":"Architecture and Dataset Info","text":""},{"location":"archds/#architecture","title":"Architecture","text":"<p>All the datasets were run on the following machine:</p> <pre><code>Hardware:\n    Model Name: MacBook Pro\n    Model Identifier: Mac15,6\n    Model Number: MRX33HN/A\n    Chip: Apple M3 Pro\n    Total Number of Cores: 11 (5 performance and 6 efficiency)\n    Memory: 18 GB\n    System Firmware Version: 11881.81.4\n    OS Loader Version: 11881.81.4\n\nSoftware:\n    System Version: macOS 15.3.2 (24D81)\n    Kernel Version: Darwin 24.3.0\n    Boot Volume: Macintosh HD\n    Boot Mode: Normal\n    Computer Name: rudy\n    Secure Virtual Memory: Enabled\n    System Integrity Protection: Enabled\n    Time since boot: 21 days, 23 minutes\n</code></pre> <p>The machine was under medium load.</p>"},{"location":"archds/#dataset-info","title":"Dataset Info","text":""},{"location":"archds/#wikipedia-vote-network","title":"Wikipedia vote network","text":"<p>The following dataset was extracted from Wikipedia Vote Network.</p> <ul> <li>This dataset includes complete administrator elections and voting history data extracted from Wikipedia\u2019s edit history (up to January 3, 2008).</li> <li>It consists of 2,794 elections with a total of 103,663 votes.</li> <li>7,066 users participated, either by voting or being voted on</li> </ul>"},{"location":"archds/#dataset-statistics","title":"Dataset Statistics","text":"<ul> <li>Nodes: 7,115</li> <li>Edges: 103,689</li> <li>Nodes in Largest WCC: 7,066 (0.993)</li> <li>Edges in Largest WCC: 103,663 (1.000)</li> <li>Nodes in Largest SCC: 1,300 (0.183)</li> <li>Edges in Largest SCC: 39,456 (0.381)</li> <li>Average Clustering Coefficient: 0.1409</li> <li>Number of Triangles: 608,389</li> <li>Fraction of Closed Triangles: 0.04564</li> <li>Diameter (Longest Shortest Path): 7</li> <li>90-Percentile Effective Diameter: 3.8</li> </ul>"},{"location":"archds/#enron-email-network","title":"Enron Email Network","text":"<p>The following dataset was extracted from the Enron Email Network.</p> <ul> <li>This dataset covers email communication within a dataset of around half a million emails.</li> <li>The data was made public by the Federal Energy Regulatory Commission during its investigation.</li> <li>Nodes represent email addresses, and an undirected edge between nodes i and j indicates that i sent at least one email to j.</li> <li>Non-Enron email addresses act as sinks and sources, meaning their communication is only observed with Enron addresses.</li> </ul>"},{"location":"archds/#dataset-statistics_1","title":"Dataset Statistics","text":"<ul> <li>Nodes: 36,692</li> <li>Edges: 183,831</li> <li>Nodes in Largest WCC: 33,696 (0.918)</li> <li>Edges in Largest WCC: 180,811 (0.984)</li> <li>Nodes in Largest SCC: 33,696 (0.918)</li> <li>Edges in Largest SCC: 180,811 (0.984)</li> <li>Average Clustering Coefficient: 0.4970</li> <li>Number of Triangles: 727,044</li> <li>Fraction of Closed Triangles: 0.03015</li> <li>Diameter (Longest Shortest Path): 11</li> <li>90-Percentile Effective Diameter: 4.8</li> </ul>"},{"location":"archds/#skitter-topology-graph","title":"Skitter Topology Graph","text":"<p>The following dataset was extracted from the CAIDA Skitter Internet Topology Dataset.</p> <ul> <li>This dataset represents an Internet topology graph from traceroutes run daily in 2005.</li> <li>The data was collected from several scattered sources to millions of destinations.</li> <li>It contains approximately 1.7 million nodes and 11 million edges.</li> </ul>"},{"location":"archds/#dataset-statistics_2","title":"Dataset Statistics","text":"<ul> <li>Nodes: 1,696,415</li> <li>Edges: 11,095,298</li> <li>Nodes in Largest WCC: 1,694,616 (0.999)</li> <li>Edges in Largest WCC: 11,094,209 (1.000)</li> <li>Nodes in Largest SCC: 1,694,616 (0.999)</li> <li>Edges in Largest SCC: 11,094,209 (1.000)</li> <li>Average Clustering Coefficient: 0.2581</li> <li>Number of Triangles: 28,769,868</li> <li>Fraction of Closed Triangles: 0.001802</li> <li>Diameter (Longest Shortest Path): 25</li> <li>90-Percentile Effective Diameter: 6</li> </ul>"},{"location":"bron-kerbosch/","title":"Listing All Maximal Cliques in Sparse Graphs in Near-optimal Time","text":"<p>David Eppstein, Maarten Loffler, and Darren Strash</p>"},{"location":"bron-kerbosch/#pseudocode","title":"Pseudocode","text":"<p>The following is the pseudocode of the algorithm</p>"},{"location":"bron-kerbosch/#bron-kerbosch-without-pivot","title":"Bron-Kerbosch without Pivot","text":"<pre><code>def bron_kerbosch(P, R, X):\n    if not P and not X:\n        print(\"Maximal Clique:\", R)\n        return\n\n    for v in list(P):  # Iterate over a copy to avoid modification issues\n        bron_kerbosch(P &amp; neighbors(v), R | {v}, X &amp; neighbors(v))\n        P.remove(v)\n        X.add(v)\n</code></pre>"},{"location":"bron-kerbosch/#bron-kerbosch-with-pivoting","title":"Bron-Kerbosch with Pivoting","text":"<pre><code>def bron_kerbosch_pivot(P, R, X):\n    if not P and not X:\n        print(\"Maximal Clique:\", R)\n        return\n\n    u = select_pivot(P | X)  # Choose pivot vertex u to maximize |P \u2229 \u0393(u)|\n    for v in list(P - neighbors(u)):  # Consider vertices not in \u0393(u)\n        bron_kerbosch_pivot(P &amp; neighbors(v), R | {v}, X &amp; neighbors(v))\n        P.remove(v)\n        X.add(v)\n</code></pre>"},{"location":"bron-kerbosch/#bron-kerbosch-with-degeneracy-ordering","title":"Bron-Kerbosch with Degeneracy Ordering","text":"<pre><code>def bron_kerbosch_degeneracy(V, E):\n    ordered_vertices = degeneracy_ordering(V, E)  # Compute degeneracy ordering\n\n    for i, v in enumerate(ordered_vertices):\n        P = {u for u in neighbors(v) if ordered_vertices.index(u) &gt; i}\n        X = {u for u in neighbors(v) if ordered_vertices.index(u) &lt; i}\n        bron_kerbosch_pivot(P, {v}, X)\n</code></pre>"},{"location":"bron-kerbosch/#recursive-approach","title":"Recursive Approach","text":"<p>The following C++ implementation is based on Efficient Enumeration of Maximal Cliques in Sparse Graphs.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#include&lt;iostream&gt;\n#include&lt;fstream&gt;\n#include&lt;sstream&gt;\n#include &lt;chrono&gt;\nusing namespace std::chrono;\nusing namespace std;\nmap&lt;int,int&gt; maximal_cliques;\n\n\n\nstruct pair_hash {\n    template &lt;class T1, class T2&gt;\n    size_t operator()(const pair&lt;T1, T2&gt;&amp; p) const {\n        return hash&lt;T1&gt;()(p.first) ^ hash&lt;T2&gt;()(p.second);\n    }\n};\n\nunordered_set&lt;int&gt; find_union(const unordered_set&lt;int&gt;&amp; R, int node) {\n    unordered_set&lt;int&gt; result = R;\n    result.insert(node);\n    return result;\n}\n\n// Function to find union of two sets\nunordered_set&lt;int&gt; find_union_set(const unordered_set&lt;int&gt;&amp; R, const unordered_set&lt;int&gt;&amp; X) {\n    unordered_set&lt;int&gt; result = R;\n    for (auto it : X) {\n        result.insert(it);\n    }\n    return result;\n}\n\n// Function to find intersection of a set and neighbors\nunordered_set&lt;int&gt; find_intersect(const unordered_set&lt;int&gt;&amp; R, const vector&lt;int&gt;&amp; neighbours) {\n    unordered_set&lt;int&gt; result;\n    for (auto it : neighbours) {\n        if (R.find(it) != R.end())\n            result.insert(it);\n    }\n    return result;\n}\n// Find set difference\nunordered_set&lt;int&gt; find_difference(const unordered_set&lt;int&gt;&amp; P, const vector&lt;int&gt;&amp; neighbours) {\n    unordered_set&lt;int&gt; difference = P;\n    for (auto it : neighbours) {\n        difference.erase(it);\n    }\n    return difference;\n}\n\n\n// Forward declaration\nvoid bron_kerbosch_pivot(set&lt;int&gt; P, set&lt;int&gt; R, set&lt;int&gt; X,\n                        vector&lt;vector&lt;int&gt;&gt;&amp;edges);\n\n// Find pivot to optimize Bron-Kerbosch\nint find_pivot(const unordered_set&lt;int&gt;&amp; P,const unordered_set&lt;int&gt;&amp;R, const unordered_set&lt;int&gt;&amp; X, const vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n    // Create union of P and X\n    unordered_set&lt;int&gt; union_set;\n    union_set.insert(P.begin(), P.end());\n    union_set.insert(X.begin(), X.end());\n\n    int max_connections = -1;\n    int pivot = -1;\n\n    // Find the vertex with the most connections to vertices in P\n    for (int u : union_set) {\n        int connections = 0;\n\n        // Count how many vertices in P are adjacent to u\n        for (int neighbor : edges[u]) {\n            if (P.find(neighbor) != P.end()) {\n                connections++;\n            }\n        }\n\n        // Update pivot if current vertex has more connections\n        if (connections &gt; max_connections) {\n            max_connections = connections;\n            pivot = u;\n        }\n    }\n\n    return pivot;\n}\n\n\n// Bron-Kerbosch with pivot\nvoid bron_kerbosch_pivot(unordered_set&lt;int&gt; P, unordered_set&lt;int&gt; R, unordered_set&lt;int&gt; X, vector&lt;vector&lt;int&gt;&gt;&amp;edges) {\n\n    unordered_set&lt;int&gt;P_union_X=find_union_set(P,X);\n    if(P_union_X.empty())\n    {\n        int cliqueSize=R.size();\n        maximal_cliques[cliqueSize]++;\n        return ;\n    }\n\n    // Use pivot to reduce recursive calls\n    int pivot = find_pivot(P,R, X, edges);\n    unordered_set&lt;int&gt; p_diff_neighbours = find_difference(P, edges[pivot]);\n\n    for (auto node : p_diff_neighbours) {\n        unordered_set&lt;int&gt; new_P = find_intersect(P, edges[node]);\n        unordered_set&lt;int&gt; new_R = find_union(R, node);\n        unordered_set&lt;int&gt; new_X = find_intersect(X, edges[node]);\n\n        bron_kerbosch_pivot(new_P, new_R, new_X, edges);\n\n        P.erase(node);\n        X.insert(node);\n    }\n}\n\n\n// Generate degeneracy ordering\nvoid find_order(vector&lt;int&gt;&amp; ans, vector&lt;int&gt;&amp; degree,\n                vector&lt;vector&lt;int&gt;&gt;&amp;edges,\n                vector&lt;int&gt;&amp;vis) {\n    for(int k=0;k&lt;edges.size();k++)\n    {\n        int u=-1;\n        int minDeg=INT_MAX;\n        for(int i=0;i&lt;edges.size();i++)\n        {\n            if(!vis[i]&amp;&amp;degree[i]&lt;minDeg)\n            {\n                minDeg=degree[i];\n                u=i;\n            }\n        }\n        if(u==-1)\n            break;\n        vis[u]=1;\n        ans.push_back(u);\n        for(int w:edges[u])\n        {\n            if(!vis[w])\n                degree[w]--;\n\n        }\n    }\n    reverse(ans.begin(),ans.end());\n\n}\n\n// Modified Bron-Kerbosch with degeneracy ordering\nvoid bron_kerbosch_modified(\n                           vector&lt;vector&lt;int&gt;&gt;&amp;edges,\n                           const vector&lt;int&gt;&amp; order,vector&lt;int&gt;&amp;pos) {\n    int nodes=edges.size();\n    for(int i=0;i&lt;nodes;i++)\n    {\n        int node_ini=order[i];\n        unordered_set&lt;int&gt;P;\n        for(int w:edges[node_ini])\n        {\n            if(pos[w]&gt;pos[node_ini]) P.insert(w);\n\n        }\n        unordered_set&lt;int&gt; X;\n        for(int w:edges[node_ini]){\n            if(pos[w]&lt;pos[node_ini]) X.insert(w);\n        }\n        unordered_set&lt;int&gt; R;\n        R.insert(node_ini);\n        bron_kerbosch_pivot(P,R,X,edges);\n    }\n\n\n\n}\n\n// Main function to find maximal cliques\nvoid  bron_kerbosch(vector&lt;vector&lt;int&gt;&gt;&amp;edges) {\n    int nodes=edges.size();\n    vector&lt;int&gt;degree(nodes,0);\n    vector&lt;int&gt;vis(nodes,0);\n    set&lt;int&gt; all_nodes;\n\n    for(int i=0;i&lt;nodes;i++)\n    {\n        degree[i]=edges[i].size();\n    }\n\n    vector&lt;int&gt; deg_order;\n    vector&lt;int&gt;pos(nodes);\n    find_order(deg_order, degree, edges, vis);\n    for(int i=0;i&lt;nodes;i++) pos[deg_order[i]] = i;\n\n    bron_kerbosch_modified(edges, deg_order,pos);\n\n\n}\n\n\nint main(int argc, char* argv[]) {\n    ifstream infile(argv[1]);\n    ofstream outfile(argv[2]);\n    string line;\n    unordered_set&lt;pair&lt;int,int&gt;,pair_hash&gt; edgeList;\n    set&lt;int&gt;nodes;\n    int maxVertex = 0;\n    printf(\"Reading dataset...........\\n\");\n    while(getline(infile, line)){\n        if(line.empty() || line[0] == '#')\n            continue;\n        istringstream iss(line);\n        int u, v;\n        if(iss &gt;&gt; u &gt;&gt; v){\n            if(u!=v){\n            edgeList.insert({u, v});\n            edgeList.insert({v,u});\n            nodes.insert(u);\n            nodes.insert(v);\n            }\n        }\n    }\n    infile.close();\n    printf(\"Mapping down edges to create edges vector....\\n\");\n    map&lt;int, int&gt; nodeMapping;\n    int newId = 0;\n    for (int node : nodes) {\n        nodeMapping[node] = newId++;\n    }\n\n    // Update edge list with new mapped values\n    vector&lt;vector&lt;int&gt;&gt; newEdgeList(newId);\n    for (auto&amp; edge : edgeList) {\n        int newU = nodeMapping[edge.first];\n        int newV = nodeMapping[edge.second];\n        newEdgeList[newU].push_back(newV);\n    }\n\n    printf(\"Entered the bron_kerbosch function......\\n\");\n    auto start = high_resolution_clock::now();\n    bron_kerbosch(newEdgeList);\n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast&lt;milliseconds&gt;(stop - start);\n    printf(\"Execution completed, printing results........\\n\");\n    outfile&lt;&lt;\"# For the dataset:\"&lt;&lt;argv[1]&lt;&lt;endl;\n    outfile&lt;&lt;\"Execution time(ms):   \"&lt;&lt;duration.count()&lt;&lt;endl;\n    long long int count=0;\n    for(auto it :maximal_cliques)\n    {\n        count+=it.second;\n        outfile&lt;&lt;\"No of cliques for Size:\"&lt;&lt;it.first&lt;&lt;\" are :\"&lt;&lt;it.second&lt;&lt;endl;\n    }\n    outfile&lt;&lt;\"Total number of maximal cliques:  \"&lt;&lt;count&lt;&lt;endl;\n    printf(\"Program executed successfully!!!\\n\");\n    outfile.close();\n\n\n    return 0;\n}\n</code></pre>"},{"location":"bron-kerbosch/#usage","title":"Usage","text":"<p>Save the above code as <code>bron-kerbosch.cpp</code></p> <p>Run the following code in a terminal.</p> <pre><code>g++ -O3 bron-kerbosch.cpp\n./a.out &lt;input_file_path&gt; &lt;output_file_path&gt;\n</code></pre> <p>Output for the code will be saved in <code>&lt;output_file_path&gt;</code>. Terminal will display any error, debugging and progress statements.</p>"},{"location":"bron-kerbosch/#results","title":"Results","text":""},{"location":"bron-kerbosch/#wiki-vote-dataset","title":"Wiki vote dataset","text":"<p>The algorithm takes 2.21 mins to run on the Wiki Vote dataset.</p> <pre><code>Execution time(ms):   132813\nNo of cliques for Size:2 are :8655\nNo of cliques for Size:3 are :13718\nNo of cliques for Size:4 are :27292\nNo of cliques for Size:5 are :48416\nNo of cliques for Size:6 are :68872\nNo of cliques for Size:7 are :83266\nNo of cliques for Size:8 are :76732\nNo of cliques for Size:9 are :54456\nNo of cliques for Size:10 are :35470\nNo of cliques for Size:11 are :21736\nNo of cliques for Size:12 are :11640\nNo of cliques for Size:13 are :5449\nNo of cliques for Size:14 are :2329\nNo of cliques for Size:15 are :740\nNo of cliques for Size:16 are :208\nNo of cliques for Size:17 are :23\n</code></pre>"},{"location":"bron-kerbosch/#email-enron-dataset","title":"Email-Enron dataset","text":"<p>The algorithm takes 2.59 mins to run on the Email Enron dataset.</p> <pre><code>Execution time(ms):   155667\nNo of cliques for Size:2 are :14070\nNo of cliques for Size:3 are :7077\nNo of cliques for Size:4 are :13319\nNo of cliques for Size:5 are :18143\nNo of cliques for Size:6 are :22715\nNo of cliques for Size:7 are :25896\nNo of cliques for Size:8 are :24766\nNo of cliques for Size:9 are :22884\nNo of cliques for Size:10 are :21393\nNo of cliques for Size:11 are :17833\nNo of cliques for Size:12 are :15181\nNo of cliques for Size:13 are :11487\nNo of cliques for Size:14 are :7417\nNo of cliques for Size:15 are :3157\nNo of cliques for Size:16 are :1178\nNo of cliques for Size:17 are :286\nNo of cliques for Size:18 are :41\nNo of cliques for Size:19 are :10\nNo of cliques for Size:20 are :6\n</code></pre>"},{"location":"bron-kerbosch/#issues","title":"Issues","text":""},{"location":"bron-kerbosch/#stack-overflow","title":"Stack Overflow","text":"<p>1.Since the algorithm uses recursion, larger graphs may run into stack overflow due to deep recursion. To avoid this, we increase the stack space to 512 Mb.</p> <p>We do this using the following code:</p> <p>VirtualAlloc is best for allocating large stack space dynamically.</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\nvoid increase_stack_size(SIZE_T stack_size = 512 * 1024 * 1024) { // 512 MB\n    LPVOID stack = VirtualAlloc(nullptr, stack_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n    if (stack == nullptr) {\n        std::cerr &lt;&lt; \"Error increasing stack size: \" &lt;&lt; GetLastError() &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Stack size increased to \" &lt;&lt; (stack_size / (1024 * 1024)) &lt;&lt; \" MB\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p>This ensures that we don't run out of stack space, even for larger graphs.</p> <p>2.Also due to deep recursions on larger dataset the Algorithm may run into SEGMENTATION fault , Thus the code requires more optimizations.</p>"},{"location":"bron-kerbosch/#optimized-approach","title":"Optimized Approach","text":"<p>(Using inline function and Mapping down nodes to continuous set of nodes stored in vectors)</p>"},{"location":"bron-kerbosch/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\nusing namespace std::chrono;\nusing namespace std;\n\n#define ll long long\n#define FREQ 1000\n\nll clique_count = 0;\nvector&lt;long long&gt; clique_counts;\nlong long max_clique_size = 0;\n\nvector&lt;int&gt; deg_order;\nvector&lt;int&gt; pos;\n\ntypedef vector&lt;int&gt; VertexSet;\n\n\ninline bool is_neighbor(int u, int v, const vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n    const vector&lt;int&gt;&amp; neighbors = edges[u];\n    return binary_search(neighbors.begin(), neighbors.end(), v);\n}\n\n\ninline void set_intersection_with_adj(const vector&lt;int&gt;&amp; adj, const VertexSet&amp; vec, VertexSet&amp; result) {\n    for (int v : adj) {\n        if (binary_search(vec.begin(), vec.end(), v)) {\n            result.push_back(v);\n        }\n    }\n}\n\n\ninline int find_pivot_sorted(const VertexSet&amp; P, const VertexSet&amp; X,\n                           const vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n    int best_pivot = -1;\n    int max_connections = -1;\n\n\n    for (int u : X) {\n        int connections = 0;\n        for (int neighbor : edges[u]) {\n            if (binary_search(P.begin(), P.end(), neighbor)) {\n                connections++;\n            }\n        }\n\n        if (connections &gt; max_connections) {\n            max_connections = connections;\n            best_pivot = u;\n        }\n    }\n\n\n    for (int u : P) {\n        int connections = 0;\n        for (int neighbor : edges[u]) {\n            if (binary_search(P.begin(), P.end(), neighbor)) {\n                connections++;\n            }\n        }\n\n        if (connections &gt; max_connections) {\n            max_connections = connections;\n            best_pivot = u;\n        }\n    }\n\n    return best_pivot == -1 ? (P.empty() ? X[0] : P[0]) : best_pivot;\n}\n\n\ninline void record_clique(size_t size) {\n    if (size &gt;= clique_counts.size()) {\n        clique_counts.resize(size + 100, 0);\n    }\n    clique_counts[size]++;\n    max_clique_size = max(max_clique_size, (long long)size);\n    clique_count++;\n    if(clique_count % FREQ == 0) {\n        cerr &lt;&lt; \"Found \" &lt;&lt; clique_count &lt;&lt; \" cliques so far.\" &lt;&lt; endl;\n    }\n}\n\n\ninline void bron_kerbosch_pivot(VertexSet&amp; P, VertexSet&amp; R, VertexSet&amp; X,\n                           const vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n    if (P.empty() &amp;&amp; X.empty()) {\n        record_clique(R.size());\n        return;\n    }\n\n\n    int pivot = find_pivot_sorted(P, X, edges);\n\n\n    VertexSet P_minus_N_pivot;\n    P_minus_N_pivot.reserve(P.size());\n\n\n    vector&lt;bool&gt; is_pivot_neighbor(edges.size(), false);\n    for (int neighbor : edges[pivot]) {\n        is_pivot_neighbor[neighbor] = true;\n    }\n\n    for (int v : P) {\n        if (!is_pivot_neighbor[v]) {\n            P_minus_N_pivot.push_back(v);\n        }\n    }\n\n\n    VertexSet new_P, new_X, new_R;\n    new_P.reserve(P.size());\n    new_X.reserve(X.size());\n    new_R.reserve(R.size() + 1);\n\n    for (int v : P_minus_N_pivot) {\n\n        new_R = R;\n        new_R.push_back(v);\n\n\n        new_P.clear();\n        set_intersection_with_adj(edges[v], P, new_P);\n        sort(new_P.begin(), new_P.end());\n\n\n        new_X.clear();\n        set_intersection_with_adj(edges[v], X, new_X);\n        sort(new_X.begin(), new_X.end());\n\n\n        bron_kerbosch_pivot(new_P, new_R, new_X, edges);\n\n\n        auto it = lower_bound(P.begin(), P.end(), v);\n        if (it != P.end() &amp;&amp; *it == v) {\n            P.erase(it);\n        }\n\n        X.push_back(v);\n        sort(X.begin(), X.end());\n    }\n}\n\n\nvoid find_order(vector&lt;int&gt;&amp; ans, vector&lt;int&gt;&amp; degree,\n               vector&lt;vector&lt;int&gt;&gt;&amp; edges,\n               vector&lt;int&gt;&amp; vis) {\n    int n = edges.size();\n    int max_degree = 0;\n\n\n    for (int i = 0; i &lt; n; i++) {\n        max_degree = max(max_degree, degree[i]);\n    }\n\n\n    vector&lt;list&lt;int&gt;&gt; buckets(max_degree + 1);\n    vector&lt;list&lt;int&gt;::iterator&gt; pos(n);\n\n\n    for (int i = 0; i &lt; n; i++) {\n        buckets[degree[i]].push_back(i);\n        pos[i] = --buckets[degree[i]].end();\n    }\n\n    for (int k = 0; k &lt; n; k++) {\n\n        int d = 0;\n        while (d &lt;= max_degree &amp;&amp; buckets[d].empty()) d++;\n\n        if (d &gt; max_degree) break;\n\n\n        int node = buckets[d].front();\n        buckets[d].pop_front();\n\n        vis[node] = 1;\n        ans.push_back(node);\n\n\n        for (int neighbor : edges[node]) {\n            if (!vis[neighbor]) {\n\n                buckets[degree[neighbor]].erase(pos[neighbor]);\n\n\n                degree[neighbor]--;\n\n\n                buckets[degree[neighbor]].push_back(neighbor);\n                pos[neighbor] = --buckets[degree[neighbor]].end();\n            }\n        }\n    }\n\n    reverse(ans.begin(), ans.end());\n}\n\n\ninline void bron_kerbosch_modified(const vector&lt;vector&lt;int&gt;&gt;&amp; edges,\n                                 const vector&lt;int&gt;&amp; order, const vector&lt;int&gt;&amp; pos) {\n    int n = edges.size();\n\n\n    VertexSet P, X, R;\n    P.reserve(n);\n    X.reserve(n);\n    R.reserve(n);\n\n    for (int i = 0; i &lt; n; i++) {\n        int v = order[i];\n        int v_pos = pos[v];\n\n\n        P.clear();\n        X.clear();\n        R.clear();\n\n        R.push_back(v);\n\n\n        for (int neighbor : edges[v]) {\n            int neighbor_pos = pos[neighbor];\n            if (neighbor_pos &gt; v_pos) {\n                P.push_back(neighbor);\n            } else if (neighbor_pos &lt; v_pos) {\n                X.push_back(neighbor);\n            }\n        }\n\n\n        sort(P.begin(), P.end());\n        sort(X.begin(), X.end());\n\n        bron_kerbosch_pivot(P, R, X, edges);\n    }\n}\n\ninline void bron_kerbosch(const vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n    bron_kerbosch_modified(edges, deg_order, pos);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc &lt; 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input_file&gt; &lt;output_file&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ifstream infile(argv[1]);\n    if (!infile) {\n        cerr &lt;&lt; \"Error: Cannot open input file \" &lt;&lt; argv[1] &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if (!outfile) {\n        cerr &lt;&lt; \"Error: Cannot open output file \" &lt;&lt; argv[2] &lt;&lt; endl;\n        return 1;\n    }\n\n    string line;\n    vector&lt;pair&lt;int, int&gt;&gt; rawEdges;\n    int maxNodeId = -1;\n\n    cerr &lt;&lt; \"Reading input file...\" &lt;&lt; endl;\n    while (getline(infile, line)) {\n        if (line.empty() || line[0] == '#')\n            continue;\n\n        istringstream iss(line);\n        int u, v;\n        if (iss &gt;&gt; u &gt;&gt; v) {\n            if (u != v) {\n                rawEdges.push_back({u, v});\n                rawEdges.push_back({v, u});\n                maxNodeId = max(maxNodeId, max(u, v));\n            }\n        }\n    }\n    infile.close();\n\n    cerr &lt;&lt; \"Finished reading input file.\" &lt;&lt; endl;\n    cerr &lt;&lt; \"Number of edges: \" &lt;&lt; rawEdges.size() / 2 &lt;&lt; endl;\n\n    if (maxNodeId == -1) {\n        outfile &lt;&lt; \"# For the dataset: \" &lt;&lt; argv[1] &lt;&lt; endl;\n        outfile &lt;&lt; \"Execution time(ms): 0\" &lt;&lt; endl;\n        outfile &lt;&lt; \"Total number of maximal cliques: 0\" &lt;&lt; endl;\n        outfile.close();\n        return 0;\n    }\n\n\n    vector&lt;bool&gt; nodeExists(maxNodeId + 1, false);\n    for (auto&amp; edge : rawEdges) {\n        nodeExists[edge.first] = true;\n        nodeExists[edge.second] = true;\n    }\n\n\n    int nodeCount = 0;\n    vector&lt;int&gt; nodeMapping(maxNodeId + 1, -1);\n    for (int i = 0; i &lt;= maxNodeId; i++) {\n        if (nodeExists[i]) {\n            nodeMapping[i] = nodeCount++;\n        }\n    }\n\n    cerr &lt;&lt; \"Graph size: \" &lt;&lt; nodeCount &lt;&lt; \" nodes\" &lt;&lt; endl;\n\n\n    vector&lt;vector&lt;int&gt;&gt; newEdgeList(nodeCount);\n    for (auto&amp; edge : rawEdges) {\n        int newU = nodeMapping[edge.first];\n        int newV = nodeMapping[edge.second];\n        newEdgeList[newU].push_back(newV);\n    }\n\n\n    for (int i = 0; i &lt; nodeCount; i++) {\n        auto&amp; neighbors = newEdgeList[i];\n        if (!neighbors.empty()) {\n\n            sort(neighbors.begin(), neighbors.end());\n            neighbors.erase(unique(neighbors.begin(), neighbors.end()), neighbors.end());\n        }\n    }\n\n    int v = nodeCount;\n    vector&lt;int&gt; degree(v, 0);\n    vector&lt;int&gt; vis(v, 0);\n    pos.resize(v);\n    deg_order.clear();\n\n    for (int i = 0; i &lt; v; i++) {\n        degree[i] = newEdgeList[i].size();\n    }\n\n\n    clique_counts.resize(1000, 0);\n\n    find_order(deg_order, degree, newEdgeList, vis);\n    for (int i = 0; i &lt; v; i++) pos[deg_order[i]] = i;\n\n    cerr &lt;&lt; \"Starting Bron-Kerbosch algorithm...\" &lt;&lt; endl;\n    auto start = high_resolution_clock::now();\n    bron_kerbosch(newEdgeList);\n    auto stop = high_resolution_clock::now();\n    cerr &lt;&lt; \"Algorithm completed.\" &lt;&lt; endl;\n\n    auto duration = duration_cast&lt;milliseconds&gt;(stop - start);\n\n    outfile &lt;&lt; \"# For the dataset: \" &lt;&lt; argv[1] &lt;&lt; endl;\n    outfile &lt;&lt; \"Execution time(ms): \" &lt;&lt; duration.count() &lt;&lt; endl;\n\n    long long total_count = 0;\n    for (int i = 1; i &lt;= max_clique_size; i++) {\n        if (i &lt; clique_counts.size() &amp;&amp; clique_counts[i] &gt; 0) {\n            outfile &lt;&lt; \"Size \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; clique_counts[i] &lt;&lt; endl;\n            total_count += clique_counts[i];\n        }\n    }\n\n    outfile &lt;&lt; \"Total number of maximal cliques: \" &lt;&lt; total_count &lt;&lt; endl;\n    outfile &lt;&lt; \"Maximal clique size: \" &lt;&lt; max_clique_size &lt;&lt; endl;\n    outfile.close();\n\n    cerr &lt;&lt; \"Results written to output file.\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"bron-kerbosch/#optimizations","title":"Optimizations","text":"<ol> <li>We used Inline functions into our optimized code , this avoids unnecessary copy creation of large sets and edge-list</li> <li>We passed parameters by reference hence optimizing large number of function calling.</li> <li>We Mapped down the random nodes number into a continuous set of nodes , so that we can avoid unnecssary complexities of using unordered-map for storing edges and instead using vector with O(1) constant T.C. for fetching adjacency list for specific nodes.</li> </ol>"},{"location":"bron-kerbosch/#usage_1","title":"Usage","text":"<p>Save the above code as <code>bron-opti.cpp</code></p> <p>Run the following code in a terminal.</p> <pre><code>g++ -O3 bron-opti.cpp\n./a.out &lt;input_file_path&gt; &lt;output_file_path&gt;\n</code></pre> <p>Output for the code will be saved in <code>&lt;output_file_path&gt;</code>. Terminal will display any error, debugging and progress statements.</p>"},{"location":"bron-kerbosch/#results_1","title":"Results","text":""},{"location":"bron-kerbosch/#wiki-vote-dataset_1","title":"Wiki vote dataset","text":"<p>The algorithm takes 0.13 mins to run on the Wiki Vote dataset.</p> <pre><code>Execution time(ms): 7546\nSize 2: 8655\nSize 3: 13718\nSize 4: 27292\nSize 5: 48416\nSize 6: 68872\nSize 7: 83266\nSize 8: 76732\nSize 9: 54456\nSize 10: 35470\nSize 11: 21736\nSize 12: 11640\nSize 13: 5449\nSize 14: 2329\nSize 15: 740\nSize 16: 208\nSize 17: 23\nTotal number of maximal cliques: 459002\nMaximal clique size: 17\n</code></pre>"},{"location":"bron-kerbosch/#email-enron-dataset_1","title":"Email-Enron dataset","text":"<p>The algorithm takes 0.1 mins to run on the Email Enron dataset.</p> <pre><code>Execution time(ms): 6208\nSize 2: 14070\nSize 3: 7077\nSize 4: 13319\nSize 5: 18143\nSize 6: 22715\nSize 7: 25896\nSize 8: 24766\nSize 9: 22884\nSize 10: 21393\nSize 11: 17833\nSize 12: 15181\nSize 13: 11487\nSize 14: 7417\nSize 15: 3157\nSize 16: 1178\nSize 17: 286\nSize 18: 41\nSize 19: 10\nSize 20: 6\nTotal number of maximal cliques: 226859\nMaximal clique size: 20\n</code></pre>"},{"location":"bron-kerbosch/#skitter-dataset","title":"Skitter dataset","text":"<p>The algorithm takes 63.51 mins to run on the Email Enron dataset.</p> <pre><code>Execution time(ms): 3810505\nSize 2: 2319807\nSize 3: 3171609\nSize 4: 1823321\nSize 5: 939336\nSize 6: 684873\nSize 7: 598284\nSize 8: 588889\nSize 9: 608937\nSize 10: 665661\nSize 11: 728098\nSize 12: 798073\nSize 13: 877282\nSize 14: 945194\nSize 15: 980831\nSize 16: 939987\nSize 17: 839330\nSize 18: 729601\nSize 19: 639413\nSize 20: 600192\nSize 21: 611976\nSize 22: 640890\nSize 23: 673924\nSize 24: 706753\nSize 25: 753633\nSize 26: 818353\nSize 27: 892719\nSize 28: 955212\nSize 29: 999860\nSize 30: 1034106\nSize 31: 1055653\nSize 32: 1017560\nSize 33: 946717\nSize 34: 878552\nSize 35: 809485\nSize 36: 744634\nSize 37: 663650\nSize 38: 583922\nSize 39: 520239\nSize 40: 474301\nSize 41: 420796\nSize 42: 367879\nSize 43: 321829\nSize 44: 275995\nSize 45: 222461\nSize 46: 158352\nSize 47: 99522\nSize 48: 62437\nSize 49: 39822\nSize 50: 30011\nSize 51: 25637\nSize 52: 17707\nSize 53: 9514\nSize 54: 3737\nSize 55: 2042\nSize 56: 1080\nSize 57: 546\nSize 58: 449\nSize 59: 447\nSize 60: 405\nSize 61: 283\nSize 62: 242\nSize 63: 146\nSize 64: 84\nSize 65: 49\nSize 66: 22\nSize 67: 4\nTotal number of maximal cliques: 37322355\nMaximal clique size: 67\n</code></pre>"},{"location":"bron-kerbosch/#improvement","title":"Improvement","text":"<ol> <li>For Wiki-Vote dataset we can observe a time reduction of 94.12%\u00a0 by using optimized approach</li> <li>For Email-Enron dataset we can observe a time reduction of 96.14% by using optimized approach</li> <li>For skitter dataser we can observe that we are able to find results without running into SEGMENTATION faults</li> </ol>"},{"location":"toc/","title":"Comparison","text":""},{"location":"toc/#assumptions","title":"Assumptions","text":"<p>We skip 1-sized cliques as they are trivial.</p> <p>By excluding 1-sized cliques across all algorithms, we ensure a fair performance comparison focused on the algorithms' ability to find non-trivial maximal cliques.</p>"},{"location":"toc/#time-complexities","title":"Time Complexities","text":""},{"location":"toc/#chiba","title":"Chiba","text":""},{"location":"toc/#preprocessing","title":"Preprocessing","text":"<ul> <li>Sorting vertices by degree: O(n log n)</li> <li>Vertex renumbering: O(n + m)</li> <li>Creating new adjacency lists: O(m)</li> </ul>"},{"location":"toc/#update","title":"UPDATE","text":"<p>The UPDATE function is called recursively to enumerate all maximal cliques. For each vertex i:</p>"},{"location":"toc/#set-operations","title":"Set Operations","text":"<p>Computing intersection and difference: O(|C| + |adj[i]|) as it uses efficient linear-time merge of sorted collections</p>"},{"location":"toc/#pruning-conditions","title":"Pruning Conditions","text":"<ul> <li>First pruning check: O(|adj[i]|)</li> <li>Second pruning check (with FLAG): O(p \u00d7 degree), where p is the size of the difference set</li> <li>Final pruning verification: O(n)</li> </ul>"},{"location":"toc/#worst-case-time-complexity","title":"Worst-Case Time Complexity","text":"<p>O(3^(n/3)), coming from:</p> <ul> <li>Moon-Moser graphs: up to 3^(n/3) maximal cliques</li> <li>Each recursive call explores two branches (include or exclude)</li> <li>Recursion depth can reach n</li> </ul>"},{"location":"toc/#space-complexity","title":"Space Complexity","text":"<ul> <li>Adjacency lists: O(n + m)</li> <li>Recursion stack: O(n) in worst case</li> <li>Auxiliary arrays S and T: O(n)</li> <li>Temporary sets and vectors: O(n)</li> </ul>"},{"location":"toc/#tomita","title":"Tomita","text":""},{"location":"toc/#expand","title":"EXPAND","text":"<p>EXPAND Function depends on</p> <ul> <li>Number of recursive calls</li> <li>Operations within each call</li> <li>Pivot selection strategy</li> </ul>"},{"location":"toc/#set-operations_1","title":"Set Operations","text":"<pre><code>vector&lt;int&gt; intersection(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\nvector&lt;int&gt; result;\nset_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\nreturn result;\n}\n\nvector&lt;int&gt; difference(vector&lt;int&gt; a, const vector&lt;int&gt;&amp; b) {\nvector&lt;int&gt; result;\nset_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\nreturn result;\n}\n</code></pre> <p>Both operations are O(|a| + |b|) since the vectors are sorted.</p>"},{"location":"toc/#pivot-selection","title":"Pivot Selection","text":"<pre><code>    for (int u : SUBG) {\n    vector&lt;int&gt; intersection_result = intersection(cand, G[u]);\n    if ((int)intersection_result.size() &gt; max_size) {\n        max_size = intersection_result.size();\n        pivot = u;\n    }\n}\n</code></pre> <ul> <li>Time complexity: O(|SUBG| \u00d7 (|cand| + max degree))</li> <li>For each vertex, we compute the intersection between candidate set and its adjacency list</li> <li>This selection process is crucial for pruning the search tree</li> </ul>"},{"location":"toc/#recursive-branching","title":"Recursive Branching","text":"<pre><code>for (int q : ext) {\n    Q.push_back(q);\n    vector&lt;int&gt; cand_q = intersection(cand, G[q]);\n    vector&lt;int&gt; subg_q = intersection(SUBG, G[q]);\n\n    EXPAND(G, cand_q, subg_q);\n\n    Q.pop_back();\n    cand.erase(remove(cand.begin(), cand.end(), q), cand.end());\n    fini.push_back(q);\n}\n</code></pre> <ul> <li><code>cand.erase(remove(...))</code> is O(|cand|)</li> <li>Each recursive call has reduced sets cand_q and subg_q</li> <li>The pivoting strategy minimizes |ext|, reducing branching factor</li> </ul>"},{"location":"toc/#overall-time-complexity","title":"Overall Time Complexity","text":"<p>The worst-case time complexity is O(3^(n/3)), where n is the number of vertices, matching the theoretical limit for maximal clique enumeration.</p> <p>For this our implementation:</p> <ol> <li>The pivot selection is optimized but still takes O(n \u00d7 d) time per recursion level</li> <li>The set operations are using standard library functions with O(n) complexity</li> <li>The dynamic set management using <code>cand.erase(remove(...))</code> has an additional overhead</li> </ol>"},{"location":"toc/#space-complexity_1","title":"Space Complexity","text":"<ul> <li>O(n) for recursion stack depth</li> <li>O(n) for the current clique (Q)</li> <li>O(n\u00b2) for graph representation (adjacency lists)</li> <li>O(k) for clique distribution map, where k is the number of different clique sizes</li> </ul> <p>The overall space complexity is O(n\u00b2).</p>"},{"location":"toc/#bron","title":"Bron","text":""},{"location":"toc/#components","title":"Components","text":"<ol> <li><code>find_order</code> - Degeneracy Ordering    Uses a bucket-based algorithm to find a degeneracy ordering    Time complexity: O(n + m) where n is the number of vertices and m is the number of edges</li> <li><code>bron_kerbosch_pivot</code> - Core Recursive Function    Worst-case time complexity for the basic Bron-Kerbosch: O(3^(n/3)) which is optimal for listing all maximal cliques    Pivot selection improves the average case but doesn't change the worst-case bound</li> <li><code>find_pivot_sorted</code> - Pivot Selection    For each candidate pivot, checks connections to vertices in P    Time complexity: O(|P| + |X|) * \u0394 where \u0394 is the maximum degree</li> <li><code>set_intersection_with_adj</code> - Set Intersection    Uses binary search to find common elements    Time complexity: O(|adj| * log(|vec|))</li> </ol>"},{"location":"toc/#overall-complexity","title":"Overall Complexity","text":"<p>Using degeneracy ordering as implemented in bron_kerbosch_modified provides a time complexity bound of O(d \u00d7 3^(d/3) \u00d7 n), where:</p> <ul> <li>d is the degeneracy of the graph (the maximum value of the minimum degree in any subgraph)</li> <li>n is the number of vertices</li> </ul> <p>For sparse graphs where d&lt;&lt; n, this significantly improves on the O(3^(n/3)) bound.</p>"},{"location":"toc/#space-complexity_2","title":"Space Complexity","text":"<ul> <li>Storage for the graph: O(n + m)</li> <li>Recursion stack depth: O(n) (worst case)</li> <li>Various temporary sets (P, R, X): O(n) each</li> </ul> <p>The total space complexity is O(n + m).</p>"},{"location":"toc/#results","title":"Results","text":"<p>The following graphs show the results obtained from the 3 algorithms</p>"},{"location":"toc/#wiki-dataset","title":"Wiki Dataset","text":""},{"location":"toc/#email-dataset","title":"Email Dataset","text":""},{"location":"toc/#skitter-dataset","title":"Skitter Dataset","text":""},{"location":"toc/#performance","title":"Performance","text":"<p>The following graphs help to visualize the performance of the 3 algorithms</p> <p> </p>"},{"location":"tomita/","title":"The worst-case time complexity for generating all maximal cliques and computational experiments","text":"<p>Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi</p>"},{"location":"tomita/#pseudocode","title":"Pseudocode","text":"<p>The following is the pseudocode of the algorithm</p> <pre><code>procedure CLIQUES(G)\n    /* Graph G = (V, E) */\n\nbegin\n    /* global variable Q is to constitute a clique */\n    Q := \u2205;\n    EXPAND(V, V)\nend of CLIQUES\n\nprocedure EXPAND(SUBG, CAND)\nbegin\n    if SUBG = \u2205\n        then print (\"clique,\")\n        /* to represent that Q is a maximal clique */\n    else\n        u := a vertex in SUBG that maximizes | CAND \u2229 \u0393(u) |;\n        /* let EXT_u = CAND \u2212 \u0393(u); */\n        /* FINI := \u2205; */\n\n        while CAND \u2212 \u0393(u) \u2260 \u2205\n        do\n            q := a vertex in (CAND \u2212 \u0393(u));\n            print (q, \",\");\n            /* to represent the next statement */\n            Q := Q \u222a {q};\n            SUBG_q := SUBG \u2229 \u0393(q);\n            CAND_q := CAND \u2229 \u0393(q);\n            EXPAND(SUBG_q, CAND_q);\n            CAND := CAND \u2212 {q}; /* FINI := FINI \u222a {q}; */\n            print (\"back,\");\n            /* to represent the next statement */\n            Q := Q \u2212 {q}\n        od\n    fi\nend of EXPAND\n</code></pre>"},{"location":"tomita/#recursive-approach","title":"Recursive Approach","text":"<p>The following C++ implementation is based on Computational Techniques for Maximum Clique Problems.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nusing Graph = vector&lt;vector&lt;int&gt;&gt;;\n\nvector&lt;int&gt; Q;\nvector&lt;vector&lt;int&gt;&gt; maximal_cliques;\n\nvector&lt;int&gt; intersection(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n    vector&lt;int&gt; result;\n    set_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\n    return result;\n}\n\nvector&lt;int&gt; difference(vector&lt;int&gt; a, const vector&lt;int&gt;&amp; b) {\n    vector&lt;int&gt; result;\n    set_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\n    return result;\n}\n\nvoid EXPAND(const Graph&amp; G, vector&lt;int&gt;&amp; cand, vector&lt;int&gt;&amp; SUBG) {\n    if (SUBG.empty()){\n        if(Q.size() &lt;= 1) {\n            return;\n        }\n        maximal_cliques.push_back(Q);\n        return;\n    }\n\n    vector&lt;int&gt; fini = difference(SUBG, cand);\n    int pivot = -1, max_size = -1;\n\n    for (int u : SUBG) {\n        vector&lt;int&gt; intersection_result = intersection(cand, G[u]);\n        if ((int)intersection_result.size() &gt; max_size) {\n            max_size = intersection_result.size();\n            pivot = u;\n        }\n    }\n\n    vector&lt;int&gt; ext = difference(cand, G[pivot]);\n\n    for (int q : ext) {\n        Q.push_back(q);\n        vector&lt;int&gt; cand_q = intersection(cand, G[q]);\n        vector&lt;int&gt; subg_q = intersection(SUBG, G[q]);\n\n        EXPAND(G, cand_q, subg_q);\n\n        Q.pop_back();\n        cand.erase(remove(cand.begin(), cand.end(), q), cand.end());\n        fini.push_back(q);\n    }\n}\n\nGraph createGraph(int n, const vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) {\n    Graph G(n);\n    for (const auto&amp; edge : edges) {\n        G[edge.first].push_back(edge.second);\n        G[edge.second].push_back(edge.first);\n    }\n    for (auto&amp; neighbors : G) {\n        sort(neighbors.begin(), neighbors.end());\n    }\n    return G;\n}\n\nvector&lt;vector&lt;int&gt;&gt; CLIQUES(const Graph&amp; G) {\n    Q.clear();\n    maximal_cliques.clear();\n\n    vector&lt;int&gt; cand(G.size()), subg(G.size());\n    for (int i = 0; i &lt; G.size(); i++) {\n        cand[i] = i;\n        subg[i] = i;\n    }\n\n    EXPAND(G, cand, subg);\n    return maximal_cliques;\n}\n\nvoid printCliquesCount(vector&lt;vector&lt;int&gt;&gt; cliques, ofstream&amp; outfile) {\n    unordered_map&lt;int, int&gt; size_count;\n\n    for (const auto&amp; clique : cliques) {\n        size_count[clique.size()]++;\n    }\n\n    vector&lt;pair&lt;int, int&gt;&gt; sorted_sizes(size_count.begin(), size_count.end());\n    sort(sorted_sizes.begin(), sorted_sizes.end());\n\n    int totalcnt=0;\n    for (const auto&amp; pair : sorted_sizes) {\n        outfile &lt;&lt; \"Size \" &lt;&lt; pair.first &lt;&lt; \": \" &lt;&lt; pair.second &lt;&lt; endl;\n        totalcnt+=pair.second;\n    }\n    outfile&lt;&lt;\"Total number of maximal cliques: \"&lt;&lt;totalcnt&lt;&lt;endl;\n}\n\n\n\nbool readGraphFromFile(const string&amp; filename, int&amp; n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) {\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cerr &lt;&lt; \"Error: Could not open file \" &lt;&lt; filename &lt;&lt; endl;\n        return false;\n    }\n\n    string line;\n    if (getline(file, line)) {\n        istringstream iss(line);\n        int m;\n        if (!(iss &gt;&gt; n &gt;&gt; m)) {\n            cerr &lt;&lt; \"Error: Invalid format for vertices and edges count\" &lt;&lt; endl;\n            return false;\n        }\n    } else {\n        cerr &lt;&lt; \"Error: Empty file\" &lt;&lt; endl;\n        return false;\n    }\n\n    edges.clear();\n    while (getline(file, line)) {\n        istringstream iss(line);\n        int u, v;\n        if (iss &gt;&gt; u &gt;&gt; v) {\n            if (u &lt; 0 || u &gt;= n || v &lt; 0 || v &gt;= n) {\n                cerr &lt;&lt; \"Warning: Edge (\" &lt;&lt; u &lt;&lt; \", \" &lt;&lt; v &lt;&lt; \") contains invalid vertex index\" &lt;&lt; endl;\n                continue;\n            }\n            edges.emplace_back(u, v);\n        } else {\n            cerr &lt;&lt; \"Warning: Invalid edge format in line: \" &lt;&lt; line &lt;&lt; endl;\n        }\n    }\n    file.close();\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    int n;\n    vector&lt;pair&lt;int, int&gt;&gt; edges;\n\n    if(argc != 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input.txt&gt; &lt;output.txt&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    if (!readGraphFromFile(argv[1], n, edges)) {\n        cerr &lt;&lt; \"Failed to read graph from input.txt\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if (!outfile.is_open()) {\n        cerr &lt;&lt; \"Error: Could not open output.txt for writing\" &lt;&lt; endl;\n        return 1;\n    }\n\n    Graph G = createGraph(n, edges);\n\n    auto start_time = high_resolution_clock::now();\n    vector&lt;vector&lt;int&gt;&gt; cliques = CLIQUES(G);\n    auto end_time = high_resolution_clock::now();\n\n    printCliquesCount(cliques, outfile);\n    outfile &lt;&lt; \"Execution time: \" &lt;&lt; duration_cast&lt;milliseconds&gt;(end_time - start_time).count() &lt;&lt; \" milliseconds\" &lt;&lt; endl;\n\n    outfile.close();\n    return 0;\n}\n</code></pre>"},{"location":"tomita/#usage","title":"Usage","text":"<p>Save the above code as <code>tomita.cpp</code></p> <p>Run the following code in a terminal.</p> <p><code>sudo</code> permissions are required to increase the recursion stack limit.</p> <pre><code>g++ -O3 tomita.cpp\n./a.out &lt;input_file_path&gt; &lt;output_file_path&gt;\n</code></pre> <p>Output for the code will be saved in <code>output.txt</code>. Terminal will display any error, debugging and progress statements.</p>"},{"location":"tomita/#issues","title":"Issues","text":""},{"location":"tomita/#stack-overflow","title":"Stack Overflow","text":"<p>Since the algorithm uses recursion, larger graphs may run into stack overflow due to deep recursion. To avoid this, we increase the stack space to 512 Mb.</p> <p>We do this using the <code>sys/resource.h</code> library with the following code:</p> <pre><code>void increase_stack_size(rlim_t stack_size = 512 * 1024 * 1024) {  // 512 MB stack\n    struct rlimit rl;\n\n    int result = getrlimit(RLIMIT_STACK, &amp;rl);\n    if (result != 0) {\n        cerr &lt;&lt; \"Error getting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        return;\n    }\n\n    if (rl.rlim_cur &lt; stack_size) {\n        rl.rlim_cur = stack_size;\n        if (rl.rlim_max &lt; rl.rlim_cur) {\n            rl.rlim_max = rl.rlim_cur;  // Also increase hard limit if necessary\n        }\n\n        result = setrlimit(RLIMIT_STACK, &amp;rl);\n        if (result != 0) {\n            cerr &lt;&lt; \"Error setting stack limit: \" &lt;&lt; strerror(errno) &lt;&lt; endl;\n        } else {\n            cerr &lt;&lt; \"Stack size increased to \" &lt;&lt; (stack_size / (1024 * 1024)) &lt;&lt; \" MB\" &lt;&lt; endl;\n        }\n    }\n}\n</code></pre> <p>This ensures that we don't run out of stack space, even for larger graphs.</p>"},{"location":"tomita/#time-complexity","title":"Time Complexity","text":"<p>This algorithm incorporates pruning techniques similar to those used in the Bron\u2013Kerbosch algorithm. The maximal cliques produced are organized in a tree-like structure. The worst-case time complexity of this algorithm is O(3<sup>n/3</sup>) for a graph with n vertices. This complexity is optimal with respect to n, as there can be up to O(3<sup>n/3</sup>) maximal cliques in an n-vertex graph.</p>"},{"location":"tomita/#optimized-approach","title":"Optimized Approach","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;chrono&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nusing Graph = vector&lt;vector&lt;int&gt;&gt;;\n\n#define FREQ 1000\n#define ll long long\n\nvector&lt;int&gt; Q;\nunordered_map&lt;int,int&gt; distro;\n\nll max_clique_size = 0;\nll clique_count = 0;\n\nvector&lt;int&gt; intersection(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n    vector&lt;int&gt; result;\n    set_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\n    return result;\n}\n\nvector&lt;int&gt; difference(vector&lt;int&gt; a, const vector&lt;int&gt;&amp; b) {\n    vector&lt;int&gt; result;\n    set_difference(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result));\n    return result;\n}\n\nvoid EXPAND(const Graph&amp; G, vector&lt;int&gt;&amp; cand, vector&lt;int&gt;&amp; SUBG) {\n    if (SUBG.empty()){\n        if(Q.size() &lt;= 1) {\n            return;\n        }\n\n        clique_count++;\n        max_clique_size = max(max_clique_size, (ll)Q.size());\n        distro[Q.size()]++;\n\n        if(clique_count % FREQ == 0) {\n            cerr &lt;&lt; \"Found Cliques: \" &lt;&lt; clique_count &lt;&lt; endl;\n        }\n        return;\n    }\n\n    vector&lt;int&gt; fini = difference(SUBG, cand);\n    int pivot = -1, max_size = -1;\n\n    for (int u : SUBG) {\n        vector&lt;int&gt; intersection_result = intersection(cand, G[u]);\n        if ((int)intersection_result.size() &gt; max_size) {\n            max_size = intersection_result.size();\n            pivot = u;\n        }\n    }\n\n    vector&lt;int&gt; ext = difference(cand, G[pivot]);\n\n    for (int q : ext) {\n        Q.push_back(q);\n        vector&lt;int&gt; cand_q = intersection(cand, G[q]);\n        vector&lt;int&gt; subg_q = intersection(SUBG, G[q]);\n\n        EXPAND(G, cand_q, subg_q);\n\n        Q.pop_back();\n        cand.erase(remove(cand.begin(), cand.end(), q), cand.end());\n        fini.push_back(q);\n    }\n}\n\nGraph createGraph(int n, const vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) {\n    Graph G(n);\n    for (const auto&amp; edge : edges) {\n        G[edge.first].push_back(edge.second);\n        G[edge.second].push_back(edge.first);\n    }\n    for (auto&amp; neighbors : G) {\n        sort(neighbors.begin(), neighbors.end());\n    }\n    return G;\n}\n\nvoid CLIQUES(const Graph&amp; G) {\n    Q.clear();\n\n    vector&lt;int&gt; cand(G.size()), subg(G.size());\n    for (int i = 0; i &lt; G.size(); i++) {\n        cand[i] = i;\n        subg[i] = i;\n    }\n\n    EXPAND(G, cand, subg);\n}\n\nbool readGraphFromFile(const string&amp; filename, int&amp; n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) {\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cerr &lt;&lt; \"Error: Could not open file \" &lt;&lt; filename &lt;&lt; endl;\n        return false;\n    }\n\n    string line;\n    if (getline(file, line)) {\n        istringstream iss(line);\n        int m;\n        if (!(iss &gt;&gt; n &gt;&gt; m)) {\n            cerr &lt;&lt; \"Error: Invalid format for vertices and edges count\" &lt;&lt; endl;\n            return false;\n        }\n    } else {\n        cerr &lt;&lt; \"Error: Empty file\" &lt;&lt; endl;\n        return false;\n    }\n\n    edges.clear();\n    while (getline(file, line)) {\n        istringstream iss(line);\n        int u, v;\n        if (iss &gt;&gt; u &gt;&gt; v) {\n            if (u &lt; 0 || u &gt;= n || v &lt; 0 || v &gt;= n) {\n                cerr &lt;&lt; \"Warning: Edge (\" &lt;&lt; u &lt;&lt; \", \" &lt;&lt; v &lt;&lt; \") contains invalid vertex index\" &lt;&lt; endl;\n                continue;\n            }\n            edges.emplace_back(u, v);\n        } else {\n            cerr &lt;&lt; \"Warning: Invalid edge format in line: \" &lt;&lt; line &lt;&lt; endl;\n        }\n    }\n    file.close();\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    int n;\n    vector&lt;pair&lt;int, int&gt;&gt; edges;\n\n    if(argc != 3) {\n        cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input.txt&gt; &lt;output.txt&gt;\" &lt;&lt; endl;\n        return 1;\n    }\n\n    if (!readGraphFromFile(argv[1], n, edges)) {\n        cerr &lt;&lt; \"Failed to read graph from input.txt\" &lt;&lt; endl;\n        return 1;\n    }\n\n    ofstream outfile(argv[2]);\n    if (!outfile.is_open()) {\n        cerr &lt;&lt; \"Error: Could not open output.txt for writing\" &lt;&lt; endl;\n        return 1;\n    }\n\n    Graph G = createGraph(n, edges);\n\n    auto start_time = high_resolution_clock::now();\n    CLIQUES(G);\n    auto end_time = high_resolution_clock::now();\n\n    outfile &lt;&lt; \"Execution time: \" &lt;&lt; duration_cast&lt;milliseconds&gt;(end_time - start_time).count() &lt;&lt; \" milliseconds\" &lt;&lt; endl;\n    outfile &lt;&lt; \"Maximal clique size: \" &lt;&lt; max_clique_size &lt;&lt; endl;\n    outfile &lt;&lt; \"Clique count: \" &lt;&lt; clique_count &lt;&lt; endl;\n    outfile &lt;&lt; \"Clique distribution:\" &lt;&lt; endl;\n\n    for (const auto&amp; entry : distro) {\n        outfile &lt;&lt; \"Size \" &lt;&lt; entry.first &lt;&lt; \": \" &lt;&lt; entry.second &lt;&lt; endl;\n    }\n\n    outfile.close();\n    return 0;\n}\n</code></pre>"},{"location":"tomita/#usage_1","title":"Usage","text":"<p>Save the above code as <code>tomita.cpp</code></p> <p>Run the following code in a terminal.</p> <p><code>sudo</code> permissions are required to increase the recursion stack limit.</p> <pre><code>g++ -O3 tomita.cpp\n./a.out &lt;input_file_path&gt; &lt;output_file_path&gt;\n</code></pre> <p>Output for the code will be saved in <code>output.txt</code>. Terminal will display any error, debugging and progress statements.</p>"},{"location":"tomita/#results","title":"Results","text":""},{"location":"tomita/#wikipedia-vote-network-dataset","title":"Wikipedia Vote Network Dataset","text":"<pre><code>Execution time: 1215 milliseconds\nMaximal clique size: 17\nClique count: 459002\nClique distribution:\nSize 17: 23\nSize 16: 208\nSize 15: 740\nSize 5: 48416\nSize 6: 68872\nSize 4: 27292\nSize 7: 83266\nSize 8: 76732\nSize 3: 13718\nSize 9: 54456\nSize 10: 35470\nSize 2: 8655\nSize 11: 21736\nSize 12: 11640\nSize 13: 5449\nSize 14: 2329\n</code></pre>"},{"location":"tomita/#enron-email-network-dataset","title":"Enron Email Network Dataset","text":"<pre><code>Execution time: 1727 milliseconds\nMaximal clique size: 20\nClique count: 226859\nClique distribution:\nSize 20: 6\nSize 18: 41\nSize 19: 10\nSize 17: 286\nSize 16: 1178\nSize 15: 3157\nSize 2: 14070\nSize 3: 7077\nSize 4: 13319\nSize 5: 18143\nSize 6: 22715\nSize 7: 25896\nSize 8: 24766\nSize 9: 22884\nSize 10: 21393\nSize 11: 17833\nSize 12: 15181\nSize 13: 11487\nSize 14: 7417\n</code></pre>"},{"location":"tomita/#as-skitter-network-dataset","title":"As Skitter Network Dataset","text":"<pre><code>Execution time: 1820871 milliseconds\nMaximal clique size: 67\nClique count: 37322355\nClique distribution:\nSize 59: 447\nSize 60: 405\nSize 61: 283\nSize 64: 84\nSize 62: 242\nSize 66: 22\nSize 67: 4\nSize 24: 706753\nSize 23: 673924\nSize 25: 753633\nSize 27: 892719\nSize 26: 818353\nSize 28: 955212\nSize 21: 611976\nSize 22: 640890\nSize 20: 600192\nSize 19: 639413\nSize 18: 729601\nSize 17: 839330\nSize 16: 939987\nSize 15: 980831\nSize 2: 2319807\nSize 3: 3171609\nSize 33: 946717\nSize 4: 1823321\nSize 63: 146\nSize 34: 878552\nSize 5: 939336\nSize 7: 598284\nSize 6: 684873\nSize 65: 49\nSize 10: 665661\nSize 8: 588889\nSize 9: 608937\nSize 12: 798073\nSize 11: 728098\nSize 13: 877282\nSize 14: 945194\nSize 30: 1034106\nSize 31: 1055653\nSize 29: 999860\nSize 32: 1017560\nSize 35: 809485\nSize 36: 744634\nSize 37: 663650\nSize 38: 583922\nSize 39: 520239\nSize 40: 474301\nSize 41: 420796\nSize 42: 367879\nSize 43: 321829\nSize 44: 275995\nSize 46: 158352\nSize 45: 222461\nSize 47: 99522\nSize 48: 62437\nSize 49: 39822\nSize 53: 9514\nSize 52: 17707\nSize 51: 25637\nSize 50: 30011\nSize 54: 3737\nSize 56: 1080\nSize 55: 2042\nSize 57: 546\nSize 58: 449\n</code></pre>"}]}